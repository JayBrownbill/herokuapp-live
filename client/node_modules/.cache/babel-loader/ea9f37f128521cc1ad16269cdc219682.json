{"ast":null,"code":"'use strict';\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar urllib = require('url');\n\nvar utillib = require('util');\n\nvar zlib = require('zlib');\n\nvar dns = require('dns');\n\nvar Stream = require('stream').Readable;\n\nvar CookieJar = require('./cookiejar').CookieJar;\n\nvar encodinglib = require('encoding');\n\nvar net = require('net');\n\nvar USE_ALLOC = typeof Buffer.alloc === 'function';\nexports.FetchStream = FetchStream;\nexports.CookieJar = CookieJar;\nexports.fetchUrl = fetchUrl;\n\nfunction FetchStream(url, options) {\n  Stream.call(this);\n  options = options || {};\n  this.url = url;\n\n  if (!this.url) {\n    return this.emit('error', new Error('url not defined'));\n  }\n\n  this.userAgent = options.userAgent || 'FetchStream';\n  this._redirect_count = 0;\n  this.options = options || {};\n  this.normalizeOptions(); // prevent errors before 'error' handler is set by defferring actions\n\n  if (typeof setImmediate !== 'undefined') {\n    setImmediate(this.runStream.bind(this, url));\n  } else {\n    process.nextTick(this.runStream.bind(this, url));\n  }\n\n  this.responseBuffer = USE_ALLOC ? Buffer.alloc(0, '', 'binary') : new Buffer(0, 'binary');\n  this.ended = false;\n  this.readyToRead = 0;\n}\n\nutillib.inherits(FetchStream, Stream);\n\nFetchStream.prototype._read = function (size) {\n  if (this.ended && this.responseBuffer.length === 0) {\n    this.push(null);\n    return;\n  }\n\n  this.readyToRead += size;\n  this.drainBuffer();\n};\n\nFetchStream.prototype.drainBuffer = function () {\n  if (this.readyToRead === 0) {\n    return;\n  }\n\n  if (this.responseBuffer.length === 0) {\n    return;\n  }\n\n  var push;\n  var rest;\n  var restSize;\n\n  if (this.responseBuffer.length > this.readyToRead) {\n    push = USE_ALLOC ? Buffer.alloc(this.readyToRead, '', 'binary') : new Buffer(this.readyToRead, 'binary');\n    this.responseBuffer.copy(push, 0, 0, this.readyToRead);\n    restSize = this.responseBuffer.length - this.readyToRead;\n    rest = USE_ALLOC ? Buffer.alloc(restSize, '', 'binary') : new Buffer(restSize, 'binary');\n    this.responseBuffer.copy(rest, 0, this.readyToRead);\n  } else {\n    push = this.responseBuffer;\n    rest = USE_ALLOC ? Buffer.alloc(0, '', 'binary') : new Buffer(0, 'binary');\n  }\n\n  this.responseBuffer = rest;\n  this.readyToRead = 0;\n\n  if (this.options.encoding) {\n    this.push(push, this.options.encoding);\n  } else {\n    this.push(push);\n  }\n};\n\nFetchStream.prototype.destroy = function (ex) {\n  this.emit('destroy', ex);\n};\n\nFetchStream.prototype.normalizeOptions = function () {\n  // cookiejar\n  this.cookieJar = this.options.cookieJar || new CookieJar(); // default redirects - 10\n  // if disableRedirect is set, then 0\n\n  if (!this.options.disableRedirect && typeof this.options.maxRedirects !== 'number' && !(this.options.maxRedirects instanceof Number)) {\n    this.options.maxRedirects = 10;\n  } else if (this.options.disableRedirects) {\n    this.options.maxRedirects = 0;\n  } // normalize header keys\n  // HTTP and HTTPS takes in key names in case insensitive but to find\n  // an exact value from an object key name needs to be case sensitive\n  // so we're just lowercasing all input keys\n\n\n  this.options.headers = this.options.headers || {};\n  var keys = Object.keys(this.options.headers);\n  var newheaders = {};\n  var i;\n\n  for (i = keys.length - 1; i >= 0; i--) {\n    newheaders[keys[i].toLowerCase().trim()] = this.options.headers[keys[i]];\n  }\n\n  this.options.headers = newheaders;\n\n  if (!this.options.headers['user-agent']) {\n    this.options.headers['user-agent'] = this.userAgent;\n  }\n\n  if (!this.options.headers.pragma) {\n    this.options.headers.pragma = 'no-cache';\n  }\n\n  if (!this.options.headers['cache-control']) {\n    this.options.headers['cache-control'] = 'no-cache';\n  }\n\n  if (!this.options.disableGzip) {\n    this.options.headers['accept-encoding'] = 'gzip, deflate';\n  } else {\n    delete this.options.headers['accept-encoding'];\n  } // max length for the response,\n  // if not set, default is Infinity\n\n\n  if (!this.options.maxResponseLength) {\n    this.options.maxResponseLength = Infinity;\n  } // method:\n  // defaults to GET, or when payload present to POST\n\n\n  if (!this.options.method) {\n    this.options.method = this.options.payload || this.options.payloadSize ? 'POST' : 'GET';\n  } // set cookies\n  // takes full cookie definition strings as params\n\n\n  if (this.options.cookies) {\n    for (i = 0; i < this.options.cookies.length; i++) {\n      this.cookieJar.setCookie(this.options.cookies[i], this.url);\n    }\n  } // rejectUnauthorized\n\n\n  if (typeof this.options.rejectUnauthorized === 'undefined') {\n    this.options.rejectUnauthorized = true;\n  }\n};\n\nFetchStream.prototype.parseUrl = function (url) {\n  var urlparts = urllib.parse(url, false, true),\n      transport,\n      urloptions = {\n    host: urlparts.hostname || urlparts.host,\n    port: urlparts.port,\n    path: urlparts.pathname + (urlparts.search || '') || '/',\n    method: this.options.method,\n    rejectUnauthorized: this.options.rejectUnauthorized\n  };\n\n  switch (urlparts.protocol) {\n    case 'https:':\n      transport = https;\n      break;\n\n    case 'http:':\n    default:\n      transport = http;\n      break;\n  }\n\n  if (transport === https) {\n    if ('agentHttps' in this.options) {\n      urloptions.agent = this.options.agentHttps;\n    }\n\n    if ('agent' in this.options) {\n      urloptions.agent = this.options.agent;\n    }\n  } else {\n    if ('agentHttp' in this.options) {\n      urloptions.agent = this.options.agentHttp;\n    }\n\n    if ('agent' in this.options) {\n      urloptions.agent = this.options.agent;\n    }\n  }\n\n  if (!urloptions.port) {\n    switch (urlparts.protocol) {\n      case 'https:':\n        urloptions.port = 443;\n        break;\n\n      case 'http:':\n      default:\n        urloptions.port = 80;\n        break;\n    }\n  }\n\n  urloptions.headers = this.options.headers || {};\n\n  if (urlparts.auth) {\n    var buf = USE_ALLOC ? Buffer.alloc(Buffer.byteLength(urlparts.auth), urlparts.auth) : new Buffer(urlparts.auth);\n    urloptions.headers.Authorization = 'Basic ' + buf.toString('base64');\n  }\n\n  return {\n    urloptions: urloptions,\n    transport: transport\n  };\n};\n\nFetchStream.prototype.setEncoding = function (encoding) {\n  this.options.encoding = encoding;\n};\n\nFetchStream.prototype.runStream = function (url) {\n  var url_data = this.parseUrl(url),\n      cookies = this.cookieJar.getCookies(url);\n\n  if (cookies) {\n    url_data.urloptions.headers.cookie = cookies;\n  } else {\n    delete url_data.urloptions.headers.cookie;\n  }\n\n  if (this.options.payload) {\n    url_data.urloptions.headers['content-length'] = Buffer.byteLength(this.options.payload || '', 'utf-8');\n  }\n\n  if (this.options.payloadSize) {\n    url_data.urloptions.headers['content-length'] = this.options.payloadSize;\n  }\n\n  if (this.options.asyncDnsLoookup) {\n    var dnsCallback = function (err, addresses) {\n      if (err) {\n        this.emit('error', err);\n        return;\n      }\n\n      url_data.urloptions.headers.host = url_data.urloptions.hostname || url_data.urloptions.host;\n      url_data.urloptions.hostname = addresses[0];\n      url_data.urloptions.host = url_data.urloptions.headers.host + (url_data.urloptions.port ? ':' + url_data.urloptions.port : '');\n\n      this._runStream(url_data, url);\n    }.bind(this);\n\n    if (net.isIP(url_data.urloptions.host)) {\n      dnsCallback(null, [url_data.urloptions.host]);\n    } else {\n      dns.resolve4(url_data.urloptions.host, dnsCallback);\n    }\n  } else {\n    this._runStream(url_data, url);\n  }\n};\n\nFetchStream.prototype._runStream = function (url_data, url) {\n  var req = url_data.transport.request(url_data.urloptions, function (res) {\n    // catch new cookies before potential redirect\n    if (Array.isArray(res.headers['set-cookie'])) {\n      for (var i = 0; i < res.headers['set-cookie'].length; i++) {\n        this.cookieJar.setCookie(res.headers['set-cookie'][i], url);\n      }\n    }\n\n    if ([301, 302, 303, 307, 308].indexOf(res.statusCode) >= 0) {\n      if (!this.options.disableRedirects && this.options.maxRedirects > this._redirect_count && res.headers.location) {\n        this._redirect_count++;\n        req.destroy();\n        this.runStream(urllib.resolve(url, res.headers.location));\n        return;\n      }\n    }\n\n    this.meta = {\n      status: res.statusCode,\n      responseHeaders: res.headers,\n      finalUrl: url,\n      redirectCount: this._redirect_count,\n      cookieJar: this.cookieJar\n    };\n\n    var curlen = 0,\n        maxlen,\n        receive = function (chunk) {\n      if (curlen + chunk.length > this.options.maxResponseLength) {\n        maxlen = this.options.maxResponseLength - curlen;\n      } else {\n        maxlen = chunk.length;\n      }\n\n      if (maxlen <= 0) {\n        return;\n      }\n\n      curlen += Math.min(maxlen, chunk.length);\n\n      if (maxlen >= chunk.length) {\n        if (this.responseBuffer.length === 0) {\n          this.responseBuffer = chunk;\n        } else {\n          this.responseBuffer = Buffer.concat([this.responseBuffer, chunk]);\n        }\n      } else {\n        this.responseBuffer = Buffer.concat([this.responseBuffer, chunk], this.responseBuffer.length + maxlen);\n      }\n\n      this.drainBuffer();\n    }.bind(this),\n        error = function (e) {\n      this.ended = true;\n      this.emit('error', e);\n      this.drainBuffer();\n    }.bind(this),\n        end = function () {\n      this.ended = true;\n\n      if (this.responseBuffer.length === 0) {\n        this.push(null);\n      }\n    }.bind(this),\n        unpack = function (type, res) {\n      var z = zlib['create' + type]();\n      z.on('data', receive);\n      z.on('error', error);\n      z.on('end', end);\n      res.pipe(z);\n    }.bind(this);\n\n    this.emit('meta', this.meta);\n\n    if (res.headers['content-encoding']) {\n      switch (res.headers['content-encoding'].toLowerCase().trim()) {\n        case 'gzip':\n          return unpack('Gunzip', res);\n\n        case 'deflate':\n          return unpack('InflateRaw', res);\n      }\n    }\n\n    res.on('data', receive);\n    res.on('end', end);\n  }.bind(this));\n  req.on('error', function (e) {\n    this.emit('error', e);\n  }.bind(this));\n\n  if (this.options.timeout) {\n    req.setTimeout(this.options.timeout, req.abort.bind(req));\n  }\n\n  this.on('destroy', req.abort.bind(req));\n\n  if (this.options.payload) {\n    req.end(this.options.payload);\n  } else if (this.options.payloadStream) {\n    this.options.payloadStream.pipe(req);\n    this.options.payloadStream.resume();\n  } else {\n    req.end();\n  }\n};\n\nfunction fetchUrl(url, options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  options = options || {};\n  var fetchstream = new FetchStream(url, options),\n      response_data,\n      chunks = [],\n      length = 0,\n      curpos = 0,\n      buffer,\n      content_type,\n      callbackFired = false;\n  fetchstream.on('meta', function (meta) {\n    response_data = meta;\n    content_type = _parseContentType(meta.responseHeaders['content-type']);\n  });\n  fetchstream.on('data', function (chunk) {\n    if (chunk) {\n      chunks.push(chunk);\n      length += chunk.length;\n    }\n  });\n  fetchstream.on('error', function (error) {\n    if (error && error.code === 'HPE_INVALID_CONSTANT') {\n      // skip invalid formatting errors\n      return;\n    }\n\n    if (callbackFired) {\n      return;\n    }\n\n    callbackFired = true;\n    callback(error);\n  });\n  fetchstream.on('end', function () {\n    if (callbackFired) {\n      return;\n    }\n\n    callbackFired = true;\n    buffer = USE_ALLOC ? Buffer.alloc(length) : new Buffer(length);\n\n    for (var i = 0, len = chunks.length; i < len; i++) {\n      chunks[i].copy(buffer, curpos);\n      curpos += chunks[i].length;\n    }\n\n    if (content_type.mimeType === 'text/html') {\n      content_type.charset = _findHTMLCharset(buffer) || content_type.charset;\n    }\n\n    content_type.charset = (options.overrideCharset || content_type.charset || 'utf-8').trim().toLowerCase();\n\n    if (!options.disableDecoding && !content_type.charset.match(/^utf-?8$/i)) {\n      buffer = encodinglib.convert(buffer, 'UTF-8', content_type.charset);\n    }\n\n    if (options.outputEncoding) {\n      return callback(null, response_data, buffer.toString(options.outputEncoding));\n    } else {\n      return callback(null, response_data, buffer);\n    }\n  });\n}\n\nfunction _parseContentType(str) {\n  if (!str) {\n    return {};\n  }\n\n  var parts = str.split(';'),\n      mimeType = parts.shift(),\n      charset,\n      chparts;\n\n  for (var i = 0, len = parts.length; i < len; i++) {\n    chparts = parts[i].split('=');\n\n    if (chparts.length > 1) {\n      if (chparts[0].trim().toLowerCase() === 'charset') {\n        charset = chparts[1];\n      }\n    }\n  }\n\n  return {\n    mimeType: (mimeType || '').trim().toLowerCase(),\n    charset: (charset || 'UTF-8').trim().toLowerCase() // defaults to UTF-8\n\n  };\n}\n\nfunction _findHTMLCharset(htmlbuffer) {\n  var body = htmlbuffer.toString('ascii'),\n      input,\n      meta,\n      charset;\n\n  if (meta = body.match(/<meta\\s+http-equiv=[\"']content-type[\"'][^>]*?>/i)) {\n    input = meta[0];\n  }\n\n  if (input) {\n    charset = input.match(/charset\\s?=\\s?([a-zA-Z\\-0-9]*);?/);\n\n    if (charset) {\n      charset = (charset[1] || '').trim().toLowerCase();\n    }\n  }\n\n  if (!charset && (meta = body.match(/<meta\\s+charset=[\"'](.*?)[\"']/i))) {\n    charset = (meta[1] || '').trim().toLowerCase();\n  }\n\n  return charset;\n}","map":null,"metadata":{},"sourceType":"script"}